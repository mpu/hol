(*
  - pure_prove_recursive_function_exists
  - new_inductive_definition
*)

needs "Library/iter.ml";;

let loop_RECURSION = prove
  (`!c b (R:S->S->bool). WF(R) /\
       (!s. R (c s) s) ==>
          ?f. !s. f s = if b s then s else f (c s)`,
  REWRITE_TAC[WF_IND] THEN REPEAT GEN_TAC THEN STRIP_TAC THEN
  ABBREV_TAC `MINI = \s:S n.
    b (ITER n c s) /\ !m. m < n ==> ~b (ITER m c s)` THEN
  SUBGOAL_THEN `!s:S. ?n:num. MINI s n` MP_TAC THENL
   (* --- *)
  [EXPAND_TAC "MINI" THEN FIRST_X_ASSUM MATCH_MP_TAC THEN
   REPEAT STRIP_TAC THEN
   ASM_CASES_TAC `(b:S->bool) s` THENL
   [EXISTS_TAC `0` THEN ASM_REWRITE_TAC[ITER; LT]; ALL_TAC] THEN
   FIRST_X_ASSUM (MP_TAC o SPEC `(c:S->S) s`) THEN
   ASM_REWRITE_TAC[] THEN DISCH_THEN (CHOOSE_THEN STRIP_ASSUME_TAC) THEN
   EXISTS_TAC `SUC n` THEN ASM_REWRITE_TAC[ITER_ALT] THEN GEN_TAC THEN
   DISJ_CASES_TAC (SPEC `m:num` num_CASES) THENL
   [ASM_REWRITE_TAC[ITER];
    POP_ASSUM (CHOOSE_THEN SUBST1_TAC) THEN
    ASM_SIMP_TAC[ITER_ALT; LT_SUC]];
   (* --- *)
   SUBGOAL_THEN `!s:S. !(k:num) l.
     MINI s k /\ MINI s l ==> k = l` ASSUME_TAC THENL
   [EXPAND_TAC "MINI" THEN REPEAT (POP_ASSUM (K ALL_TAC)) THEN
    REPEAT STRIP_TAC THEN
    REWRITE_TAC [ARITH_RULE `k = l <=> ~(k < l) /\ ~(l < k)`] THEN
    CONJ_TAC THEN DISCH_THEN(fun i -> FIRST_ASSUM(MP_TAC o C MATCH_MP i)) THEN
    ASM_REWRITE_TAC[]; ALL_TAC] THEN
   STRIP_TAC THEN EXISTS_TAC `\s:S. ITER (@n:num. MINI s n) c s` THEN
   BETA_TAC THEN REPEAT STRIP_TAC THEN COND_CASES_TAC THENL
    (* case: b s *)
   [SUBGOAL_THEN `(@n:num. MINI (s:S) n) = 0`
     (fun th -> REWRITE_TAC[ITER; th]) THEN
    FIRST_ASSUM MATCH_MP_TAC THEN
    EXISTS_TAC `s:S` THEN CONV_TAC (DEPTH_CONV SELECT_CONV) THEN
    CONJ_TAC THENL [FIRST_ASSUM MATCH_ACCEPT_TAC; ALL_TAC] THEN
    EXPAND_TAC "MINI" THEN ASM_REWRITE_TAC[ITER; LT];
    (* case: ~b s *)
    SUBGOAL_THEN `(@n:num. MINI (s:S) n) = SUC (@n. MINI (c s) n)`
     (fun th -> REWRITE_TAC[ITER_ALT; th]) THEN
    FIRST_ASSUM MATCH_MP_TAC THEN
    EXISTS_TAC `s:S` THEN CONV_TAC (DEPTH_CONV SELECT_CONV) THEN
    CONJ_TAC THENL [FIRST_ASSUM MATCH_ACCEPT_TAC; ALL_TAC] THEN
    SUBGOAL_THEN `!n:num. MINI ((c:S->S) s) n <=> MINI s (SUC n)`
      (fun th -> REWRITE_TAC[th]) THENL
    [POP_ASSUM MP_TAC THEN EXPAND_TAC "MINI" THEN
     REPEAT (POP_ASSUM (K ALL_TAC)) THEN REPEAT STRIP_TAC THEN EQ_TAC THEN
     REWRITE_TAC[ITER_ALT] THEN STRIP_TAC THEN ASM_REWRITE_TAC[] THENL
     [GEN_TAC THEN DISCH_THEN (MP_TAC o MATCH_MP (
        MESON[num_CASES; LT_SUC]
         `(m < SUC n) ==> m = 0 \/ ?k. (m = SUC k /\ k < n)`)) THEN
      DISCH_THEN(DISJ_CASES_THEN STRIP_ASSUME_TAC) THEN ASM_SIMP_TAC[ITER_ALT];
      GEN_TAC THEN STRIP_TAC THEN
      REWRITE_TAC[GSYM ITER_ALT] THEN FIRST_ASSUM MATCH_MP_TAC THEN
      ASM_REWRITE_TAC[LT_SUC]]; ALL_TAC] THEN
     (* *)
    ONCE_REWRITE_TAC[GSYM o_THM] THEN
    GEN_REWRITE_TAC (RAND_CONV o ONCE_DEPTH_CONV) [GSYM o_THM] THEN
    CONV_TAC SELECT_CONV THEN REWRITE_TAC[o_THM] THEN
    FIRST_X_ASSUM (CHOOSE_THEN MP_TAC o SPEC `s:S`) THEN
    DISJ_CASES_TAC (SPEC `n:num` num_CASES) THENL
    [POP_ASSUM SUBST1_TAC THEN EXPAND_TAC "MINI" THEN ASM_REWRITE_TAC[ITER];
     POP_ASSUM MP_TAC THEN MESON_TAC[]]]]);;
