prioritize_int();;

let INT_SUB_1_REM = prove
  (`!m x. (x - &1) rem m = if x rem m = &0 then abs m - &1 else x rem m - &1`,
   REPEAT GEN_TAC THEN ASM_CASES_TAC `m = &0` THENL
     [ASM_REWRITE_TAC[INT_REM_0] THEN INT_ARITH_TAC; ALL_TAC] THEN
   COND_CASES_TAC THEN MATCH_MP_TAC INT_REM_UNIQ THENL
   [ EXISTS_TAC `x div m - int_sgn m` THEN
     POP_ASSUM MP_TAC THEN REWRITE_TAC[INT_REM_DIV] THEN
     STRIP_TAC THEN REPEAT CONJ_TAC THENL
     [ REWRITE_TAC[INT_SUB_RDISTRIB; INT_SGN_ABS_ALT] THEN ASM_INT_ARITH_TAC;
       ASM_INT_ARITH_TAC;
       INT_ARITH_TAC ];
     EXISTS_TAC `x div m` THEN
     STRIP_TAC THEN REPEAT CONJ_TAC THENL
     [ REWRITE_TAC[INT_REM_DIV] THEN INT_ARITH_TAC;
       POP_ASSUM MP_TAC THEN
       POP_ASSUM (MP_TAC o SPEC `x:int` o MATCH_MP INT_REM_POS) THEN
       INT_ARITH_TAC;
       POP_ASSUM (K ALL_TAC) THEN
       POP_ASSUM (MP_TAC o MATCH_MP INT_DIVISION) THEN
       DISCH_THEN (MP_TAC o CONJUNCT2 o CONJUNCT2 o SPEC `x:int`) THEN
       INT_ARITH_TAC ] ]);;

let MODSUB_ADD_1 = prove
  (`!m x y. ~(x == y) (mod m) ==> (x - (y + &1)) rem m = (x - y) rem m - &1`,
   REPEAT STRIP_TAC THEN
   REWRITE_TAC[INT_ARITH `x - (y + &1) = x - y - &1`; INT_SUB_1_REM] THEN
   SUBGOAL_THEN `~((x - y) rem m = &0)` (fun th -> REWRITE_TAC[th]) THEN
   POP_ASSUM MP_TAC THEN REWRITE_TAC[CONTRAPOS_THM] THEN
   REWRITE_TAC[INT_REM_EQ_0; int_divides; int_congruent]);;

let MODSEG = define
  `MODSEG m a b =
    if a MOD m <= b MOD m
    then {x | (m = 0 \/ x < m) /\
              (a MOD m <= x MOD m /\
               x MOD m <= b MOD m)}
    else {x | (m = 0 \/ x < m) /\
              (a MOD m <= x MOD m \/
               x MOD m <= b MOD m)}`;;

let MODSEG_ZERO =
  (SPEC_ALL o REWRITE_RULE[MOD_ZERO] o SPEC `0:num` o GEN `m:num`) MODSEG;;

let INT_OF_NUM_SUB_REM = prove
  (`!m a b. ~(m = 0) ==>
      (&b - &a) rem &m =
      &(if a MOD m <= b MOD m
        then b MOD m - a MOD m
        else b MOD m + m - a MOD m)`,
   REPEAT STRIP_TAC THEN
   ONCE_REWRITE_TAC[GSYM INT_SUB_REM] THEN
   REWRITE_TAC[INT_OF_NUM_REM] THEN
   REPEAT GEN_TAC THEN COND_CASES_TAC THENL
   [ IMP_REWRITE_TAC[INT_OF_NUM_SUB] THEN
     REWRITE_TAC[INT_OF_NUM_REM; INT_OF_NUM_EQ; MOD_EQ_SELF] THEN
     DISJ2_TAC THEN ASM_ARITH_TAC;
     ONCE_REWRITE_TAC[INT_ARITH `x - y = -- (y - x)`] THEN
     REWRITE_TAC[INT_REM_LNEG] THEN IMP_REWRITE_TAC[INT_OF_NUM_SUB] THEN
     REWRITE_TAC[INT_OF_NUM_REM; INT_OF_NUM_EQ; INT_ABS_NUM] THEN
     SUBGOAL_THEN `(a MOD m - b MOD m) MOD m = a MOD m - b MOD m`
       SUBST1_TAC THENL
     [ REWRITE_TAC[MOD_EQ_SELF] THEN DISJ2_TAC THEN ASM_ARITH_TAC;
       SUBGOAL_THEN `~(a MOD m - b MOD m = 0)`
         (fun th -> REWRITE_TAC[th]) THENL
         [POP_ASSUM MP_TAC THEN ARITH_TAC; ALL_TAC] THEN
       POP_ASSUM (ASSUME_TAC o REWRITE_RULE[NOT_LE]) THEN
       IMP_REWRITE_TAC[INT_OF_NUM_SUB; INT_OF_NUM_EQ] THEN
       REPEAT CONJ_TAC THENL
       [ MATCH_MP_TAC (ARITH_RULE
           `(b:num) < a /\ a < m ==> m - (a - b) = b + m - a`) THEN
         ASM_REWRITE_TAC[MOD_LT_EQ_LT; LT_NZ];
         ASM_ARITH_TAC;
         ASM_ARITH_TAC ]
     ]
   ]);;

let MODSEG_NON_ZERO = prove
  (`!m a b. ~(m = 0) ==>
      MODSEG m a b = {x | x < m /\ (&x - &a) rem &m <= (&b - &a) rem &m}`,
   SIMP_TAC[MODSEG; EXTENSION] THEN REPEAT STRIP_TAC THEN
   SUBGOAL_THEN `a MOD m < m /\ b MOD m < m /\ x MOD m < m`
     STRIP_ASSUME_TAC THENL [ASM_ARITH_TAC; ALL_TAC] THEN
   IMP_REWRITE_TAC[INT_OF_NUM_SUB_REM; INT_OF_NUM_LE] THEN
   REPEAT COND_CASES_TAC THEN REWRITE_TAC[IN_ELIM_THM] THEN
   REPEAT (POP_ASSUM MP_TAC) THEN SIMP_TAC[] THEN
   MAP_EVERY SPEC_TAC [(`a MOD m`,`a:num`);(`b MOD m`,`b:num`);
                       (`x MOD m`,`X:num`)] THEN
   ARITH_TAC);;

let FIRST_IN_MODSEG = prove
  (`!m a b. a MOD m IN MODSEG m a b`,
   REPEAT GEN_TAC THEN REWRITE_TAC[MODSEG] THEN COND_CASES_TAC THEN
   ASM_REWRITE_TAC[IN_ELIM_THM; MOD_MOD_REFL; LE_REFL] THEN
   REWRITE_TAC[MOD_LT_EQ_LT] THEN ARITH_TAC);;

(* TODO: generalize *)
let MODSEG_REC = prove
  (`!m a b. ~(m = 0) ==>
      MODSEG m a b =
      if (a == b) (mod m)
      then {a MOD m}
      else a MOD m INSERT MODSEG m (SUC a) b`,
   REWRITE_TAC[CONG; EXTENSION] THEN REPEAT STRIP_TAC THEN
   ASM_SIMP_TAC[MODSEG_NON_ZERO] THEN
   COND_CASES_TAC THEN REWRITE_TAC[IN_ELIM_THM; IN_SING; IN_INSERT] THENL
   [ ASM_SIMP_TAC[INT_OF_NUM_SUB_REM; SUB_REFL; LE_REFL; INT_OF_NUM_LE;
       MESON[MOD_EQ_SELF] `~(m = 0) ==> (n < m <=> n = n MOD m)`] THEN
     EQ_TAC THEN SIMP_TAC[MOD_MOD_REFL; LE_REFL; SUB_REFL] THEN ASM_ARITH_TAC;
     (* --- *)
     ASM_SIMP_TAC[
       MESON[MOD_EQ_SELF] `~(m = 0) ==> (n < m <=> n = n MOD m)`] THEN
     EQ_TAC THEN STRIP_TAC THEN ASM_SIMP_TAC[MOD_MOD_REFL] THENL
     [ FIRST_X_ASSUM SUBST1_TAC THEN REWRITE_TAC[MOD_MOD_REFL] THEN
       ASM_CASES_TAC `x MOD m = a MOD m` THEN ASM_REWRITE_TAC[] THEN
       REWRITE_TAC[GSYM INT_OF_NUM_REM; GSYM INT_OF_NUM_SUC] THEN
       ONCE_REWRITE_TAC[GSYM INT_SUB_REM] THEN
       MAP_EVERY REWRITE_TAC [[INT_REM_REM]; [INT_SUB_REM]] THEN
       IMP_REWRITE_TAC[MODSUB_ADD_1] THEN
       REWRITE_TAC[GSYM num_congruent; CONG] THEN
       REPEAT CONJ_TAC THENL
         [ASM_INT_ARITH_TAC; ASM_MESON_TAC[]; ASM_MESON_TAC[]];
       (* --- *)
       REWRITE_TAC[GSYM INT_OF_NUM_REM; GSYM INT_OF_NUM_SUC] THEN
       ONCE_REWRITE_TAC[GSYM INT_SUB_REM] THEN
       MAP_EVERY REWRITE_TAC [[INT_REM_REM]; [INT_SUB_REM]] THEN
       REWRITE_TAC[INT_SUB_REFL; INT_REM_ZERO] THEN
       MATCH_MP_TAC INT_REM_POS THEN
       ASM_REWRITE_TAC[INT_OF_NUM_EQ];
       (* --- *)
       CONJ_TAC THENL [FIRST_ASSUM ACCEPT_TAC; ALL_TAC] THEN
       POP_ASSUM MP_TAC THEN
       REWRITE_TAC[GSYM INT_OF_NUM_REM; GSYM INT_OF_NUM_SUC] THEN
       ASM_CASES_TAC `(&x == &a) (mod &m)` THENL
       [ DISCH_THEN (K ALL_TAC) THEN
         POP_ASSUM MP_TAC THEN REWRITE_TAC[int_congruent] THEN
         DISCH_THEN (CHOOSE_THEN SUBST1_TAC) THEN
         REWRITE_TAC[INT_REM_MUL] THEN
         ASM_SIMP_TAC[INT_REM_POS; INT_OF_NUM_EQ];
         IMP_REWRITE_TAC[MODSUB_ADD_1] THEN
         REWRITE_TAC[GSYM num_congruent; CONG] THEN
         ONCE_REWRITE_TAC[EQ_SYM_EQ] THEN
         ASM_SIMP_TAC[] THEN INT_ARITH_TAC ]
     ]
   ]);;

prioritize_num();;

let MODLOOP_IND = prove
  (`!m y P.
      ~(m = 0) /\
      (!x. (x == y) (mod m) ==> P x) /\
      (!x. (~(x == y) (mod m) /\ P (SUC x)) ==> P x) ==>
      !x. P x`,
   REPEAT GEN_TAC THEN DISCH_THEN (CONJUNCTS_THEN ASSUME_TAC) THEN
   SUBGOAL_THEN `WF (MEASURE (\x. num_of_int((&y - &x) rem &m)))` MP_TAC THENL
     [REWRITE_TAC[WF_MEASURE]; REWRITE_TAC[WF_IND]] THEN
   DISCH_THEN MATCH_MP_TAC THEN REWRITE_TAC[MEASURE] THEN
   GEN_TAC THEN POP_ASSUM (CONJUNCTS_THEN (MP_TAC o SPEC `x:num`)) THEN
   ASM_CASES_TAC `(x == y) (mod m)` THEN ASM_SIMP_TAC[] THEN
   REWRITE_TAC[IMP_IMP] THEN DISCH_THEN (CONJUNCTS_THEN MATCH_MP_TAC) THEN
   ONCE_REWRITE_TAC[GSYM INT_OF_NUM_LT] THEN
   ASM_SIMP_TAC[INT_REM_POS; INT_OF_NUM_OF_INT; INT_OF_NUM_EQ] THEN
   REWRITE_TAC[GSYM INT_OF_NUM_SUC] THEN IMP_REWRITE_TAC[MODSUB_ADD_1] THEN
   CONJ_TAC THENL [INT_ARITH_TAC; ASM_MESON_TAC[num_congruent; CONG]]);;
